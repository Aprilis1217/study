# **js 原理题**

- **实现 `call` 函数**

  ```javascript
  const MyCall = (context, ...args) => {
      if (typeof context === 'object' || typeof context === 'function') {
          context = context || window
      } else {
          context = Object.create(null)
      }
      let fn = Symbol('fn') // 利用 Symbol 的唯一性生成不重复的键
      context[fn] = this // 将调用函数设为对象的方法
      let result = context[fn](...args) // 重点代码：利用 this 指向
      delete context[fn] // 将属性删除
      return result
  }
  ```

- **实现`apply`函数**

  ```javascript
  const MyApply = (context, args) => {
      if (typeof context === 'object' || typeof context === 'function') {
          context = context || window
      } else {
          context = Object.create(null)
      }
      let fn = Symbol('fn')
      context[fn] = this
      let result = context[fn](...args)
      delete context[fn]
      return result
  }
  ```

  

- **实现`bind`函数**

  ```javascript
  const MyBind = (context, ...args) => {
      let self = this // 谨记 this 表示调用 bind 的函数
      let bindFn = (...newArfs) => {
          // this instanceof bindFn 为 true 表示构造函数的情况 如：new func.bind(obj)
          return self.call(this instanceof bindFn ? this : context||window, ...args, ...newArgs)
      }
      bindFn.prototype = Object.create(self.prototype) // 保证原函数的原型对象上的属性不丢失
      return bindFn
  }
  ```

  

<!-- call apply bind 三者的区别 -->

1. `fn.call(obj, arg1, arg2...)`
2. `fn.bind(obj, [arg1, arg2...])`
3. `const Temp = fn.bind(obj, arg1, arg2...)`
   - <u>第一个参数都是指定函数内部中 `this` 的指向（函数执行时所在的作用域），然后根据指定的作用域调用函数</u>

   - <u>都可以在函数调用时传递参数，`call` 和 `bind` 方法需要直接传入，`apply`方法需要以数组的形式传入</u>

   - `call`和`apply`都是在调用后立即执行，而`bind`调用后是返回原函数，需要在调用一才行

     

- **实现`new`关键字**

  ```javascript
  const MyNew = (Con, ...args) => {
      let obj = {}
      // obj.__proto__ = Con.prototype
      Oject.setPrototypeOf(obj, Con.prototype) // ES6 语法 设置构造函数原型上
      let result = Con.apply(obj, args)
      return result instanceof Object ? result : obj
  }
  ```

  <!-- new 关键字做了什么？ -->

  1. 创建一个新的空对象

  2. 将对象连接到构造函数的原型上，并绑定 `this`

  3. 执行构造函数代码

  4. 返回新对象

     

- **实现`instanceof`方法**

  ```javascript
  const MyInstanceof = (left, right) => {
      let prototype = right.prototype // 获取类型的原型
      // let proto = left.__proto__ // ES5 获取对象的原型
      let proto = Object.getPrototypeOf(left) // ES6 获取对象的原型
      while (true) {
          if (proto === null || proto === undefined) return false
          if (prototype === proto) return true
          proto = proto.__proto__
      }
  }
  ```

  <!-- instanceof 原理 -->

  1. 获取类型的原型
  2. 获取对象的原型
  3. 然后一直循环判断对象的原型是否等于类型的原型，直到对象的原型为`null`，因为原型链最终为`null`

- **实现`Object.create()`方法**

  ```javascript
  const MyCreate = (proto) => {
      function Fn () {}
      Fn.prototype = proto
      Fn.prototype.constructor = Fn
      return new Fn()
  }
  ```

- **实现`Array.prototype.map`方法**

  <!-- map()方法是将数组中的每一项调用提供的函数，结果返回一个新数组，并没有改变原来的数组  -->

  ```javascript
  const MyMap = (arr, mapCallback) => {
      // 首先检查传递的参数是否正确
      if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') {
          return []
      } else {
          let result = [] // 每次调用此函数时都回去创建一个 result 空数组
          // 不改变原数组
          for (let i = 0; i < arr.length; i++) {
              // 将 mapCallback 返回的结果 push 到 result 数组中
              result.push(mapCallback(arr[i], i, arr))
          }
          return result
      }
  }
  ```

- **实现`Array.prototype.filter`方法**

  <!-- filter()方法是将数组中所有的元素进行判断，将满足条件的元素作为一个新数组返回 -->

  ```javascript
  const MyFilter = (arr, filterCallback) {
      if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function') {
          return []
      } else {
         let result = []
         for (let i = 0; i < arr.length; i++) {
             if (filterCallback(arr[i], i, arr)) {
                 // 如果条件为真，则将数组元素 push 到 result 中
                 result.push(arr[i])
             }
         }
          return result
      }
  }
  ```

- **实现`Array.prototype.reduce`方法**

  <!-- reduce()方法是所有元素调用返回函数，返回值为最后结果，传入的值必须是函数类型  -->

  ```javascript
  const MyReduce = (arr, reduceCallback, initValue) => {
      if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== 'function') {
          return []
      } else {
          let hasInitValue = initValue !== undefined
          let value = hasInitValue ? initValue : arr[0]
          // 如果有传递 initValue，则索引从 1 开始，否则从 0 开始
          for (let i = hasInitValue ? 1 : 0; i < arr.length; i++) {
              value = reduceCallback(value, arr[i], i, arr)
          }
          return value
      }
  }
  ```

- **对象的拷贝**

  ```javascript
  // 浅拷贝：Object.assign() 和 扩展运算符
  // 不能拷贝对象的继承属性；
  // 不能拷贝不可枚举的属性;
  // 只是在 根属性（对象的第一层）创建了一个新对象，但是对于属性的值是对象的话只会拷贝一份相同的内存地址；
  // 可以拷贝 Symbol 类型
  let obj = {
      a: {aa: 1},
      b: function () {},
      c: null,
      d: undefined,
      e: NaN,
      sym: Symbol('sym')
  }
  Object.defineProperty(obj, 'innumerable', {value: '不可枚举属性', enumerable: false})
  obj.a.aa = 2
  let obj1 = {}
  Object.assign(obj1, obj)
  console.log('Object.assign', obj1)
  let obj2 = {...obj}
  console.log('扩展运算符', obj2)
  
  ```

  ```javascript
  // 深拷贝：将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，并且修改了新对象不会影响原对象
  let deepObj = {
      num: 0,
  	str: "",
  	boolean: true,
  	unf: undefined,
  	nul: null,
  	obj: {
  	   name: "我是一个对象",
  	   id: 1
  	},
  	arr: [0, 1, 2],
  	func: function() {
  	   console.log("我是一个函数");
  	},
  	date: new Date(0),
  	reg: new RegExp("/我是一个正则/ig"),
  	[Symbol("1")]: 1
  }
  Object.defineProperty(deepObj, 'innumerable', {value: '不可枚举属性', enumerable: false})
  // 通过 JSON.parse(JSON.stringify()) 实现简单的深拷贝
  let deepObj1 = JSON.parse(JSON.stringify(deepObj))
  console.log('JSON.stringify()', deepObj1)
  // 使用 JSON.stringify() 深拷贝的注意点：
  // 1. 无法拷贝不可枚举属性，无法拷贝对象原型链
  // 2. 拷贝对象的属性值中如果有 函数 undefined symbol 经过 JSON.stringify() 序列化后的JSON字符串中的这个键值对会消失
  // 3. 拷贝 Date 引用类型会转变成字符串
  // 4. 拷贝 RegExp 引用类型会转变成空对象
  // 5. 对象中包含有 NaN Infinity -Infinity 序列化之后会变成 null
  // 6. 无法拷贝对象的循环引用（对象成环）obj[key] = obj
  ```

  ```javascript
  // 深度拷贝封装
  const isObjectType = obj => obj !== null && (typeof obj === 'object' || typeof obj === 'function') // 判断 obj 类型
  const deepClone = (obj, hash = new WeakMap()) => {
      // 如果 obj 是日期对象就返回一个新的日期对象
      if (obj.constructor === Date) return new Date(obj)
      // 如果 obj 是正则对象就返回一个新的正则对象
      if (obj.constructor === RegExp) return new RegExp(obj)
      // 如果成环了，参数 obj = obj.loop = 最初的 obj 会在 weakMap 中知道到第一次放入的 obj 提前返回第一次放入的 WeakMap 的 cloneObj
      if (hash.has(obj)) return hash.get(obj)
      // 遍历传入参数所有键的特性
      let allKeyDesc = Object.getOwnPropertyDescriptors(obj)
      // 继承原型链
      let cloneObj = Object.create(Object.getPrototypeOf(obj), allKetDesc)
      hash.set(obj, cloneObj)
      for (let key of Reflect.ownKeys(obj)) {
          // Reflect.ownKeys(obj) 可以拷贝不枚举属性和符号类型
          // 如果值是引用类型（非函数）则递归调用 deepClone
          cloneObj[key] = isObjectType(obj[key]) && typeof obj[key] !== 'function' ? deepClone(obj[key], hash) : obj[key]
          
      }
      return cloneObj
  }
  let deepObj = {
      num: 0,
  	str: "",
  	boolean: true,
  	unf: undefined,
  	nul: null,
  	obj: {
  	   name: "我是一个对象",
  	   id: 1
  	},
  	arr: [0, 1, 2],
  	func: function() {
  	   console.log("我是一个函数");
  	},
  	date: new Date(0),
  	reg: new RegExp("/我是一个正则/ig"),
  	[Symbol("1")]: 1
  }
  Object.defineProperty(obj, 'innumerable', {value: '不可枚举属性', enumerable: false})
  obj.loop = obj
  let deepCloneObj = deepClone(obj)
  console.log('obj', obj)
  console.log('deepCloneObj', deepCloneObj)
  for (let key of Object.keys(deepCloneObj)) {
      if (typeof deepCloneObj[key] === 'object' || typeof deepCloneObj[key] === 'function') {
          console.log(`${key}相同吗`, deepCloneObj[key] === obj[key])
      }
  }
  ```

  

- **函数防抖**

  1. 函数防抖：指触发事件在 n 秒内函数只执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

  2. 简单来说就是当一个动作连续触发，只执行最后一次

  3. 应用场景：搜索框搜索输入，只需要最后一次输入完在发送请求

     ```javascript
     /**
     * @desc 函数防抖
     * @param fn 函数
     * @param wait 延迟执行时间
     * @param immediate true 立即执行 false 非立即执行
     */
     const Debounce = (fn, wait = 500, immediate = true) => {
         let timer = null
         return (...args) => {
             if (timer) clearTimeout(timer)
             if (immediate) { // 立即执行
                 const callNow = !timer
                 timer = setTimeout(() => {
                     timer = null
                 }, wait)
                 if (callNow) fn.apply(this, args)
             } else { // 非立即执行
                 timer = setTimeout(() => {
                     fn.apply(this, args)
                 }, wait)
             }
         }
     }
     ```

     

- **函数节流**

  1. 函数节流：限制一个函数在一定时间内只执行一次

  2. 应用场景：滚动加载，加载更多或者滚到底部监听；高频点击事件，表单重复提交

     ```javascript
     /**
     * @desc 函数节流
     * @param fn 函数
     * @param wait 延迟执行毫秒数
     * @param type 1 时间戳版 2 定时器版
     */
     const Throttle = (fn, wait = 500, type) => {
         let previous = 0
         let timer = null
         return (...args) => {
             if (type === 1) {
                 let now = Date.now()
                 if (now - previous > wait) {
                     fn.apply(this, args)
                 }
             } else if (type === 2) {
                 if (!timer) {
                     timer = setTimeout(() => {
                         timer = null
                         fn.apply(this, args)
                     }, wait)
                 }
             }
         }
     }
     ```

     

- **冒泡排序**

  ```javascript
  const SortArr = (arr) => {
      // 外层循环  控制循环的次数，每次找到最大值
      for (let i = 0; i < arr.length - 1; i++) {
          // 定义一个布尔变量来判断是否排好
          let flag = true // 初始值 true 假设排好了
          // 内层循环  控制两两比较的次数，并且要判断两个数的大小，大的数往后移，小的数往前移
          for (let j = 0; j < arr.length - i - 1; j++) {
              if (arr[j] > arr[j + 1]) {
                  flag = false
                  let temp = arr[j]
                  arr[j] = arr[j + 1]
                  arr[j + 1] = temp
              }
          }
          if (flag) break;
      }
      return arr
  }
  let arrSort = [110, 28, 520, 1314, 18, 11];
  arrSort.sort((a, b) => {
      // return a - b;
      return b - a; // 从大到小
   })
  ```

  

- **实现斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21...**

  ```javascript
  const Fibonacci = (n) => {
      let [a, b, c] = [1, 1, null]
      // 循环版
      for (let i = 2; i < n; i++) {
          // 用 num3 累加前两个数的和，也是斐波那契数列的精髓所在
          c = a + b
          a = b
          b = c
      }
      if (n === 1 || n === 2) return a
      return c
  }
  // 递归版
  function fibonacci (n) {
      function fibonacci(n, a, b) {
          if (n === 0) {
              return a
          } else {
              return fibonacci(n - 1, b, a + b)
          }
      }
      return fibonacci(n, 0, 1)
  }
  ```

  

- **什么是闭包？**

  <!-- Javascript高级程序设计（第三版）中描述：闭包是指有权访问另一个函数作用域中变量的函数 -->

  <u>我的理解：闭包是可以访问另一个函数作用域中变量的函数。而被访问的变量可以和函数一同存在。即使另一个函数已经运行结束导致创建变量的环境销毁，也会依然存在</u>

  - 注意点：闭包只能取得包含函数中任何变量的最后一个值，因为闭包所保存的是整个变量对象，而不是某个特殊的变量

  - 闭包导致变量不会被垃圾机制回收处理，可能导致内存泄漏，因此谨慎使用闭包

    ```HTML
    <p id="help">Helpful notes will appear here</p>
    <p>E-mail: <input type="text" id="email" name="email"></p>
    <p>Name: <input type="text" id="name" name="name"></p>
    <p>Age: <input type="text" id="age" name="age"></p>
    <script>
        function showHelp (help) {
          document.getElementById('help').innerHTML = help
        }
        const setupHelp = () => {
            const helpText = [
                {'id': 'email', 'help': 'Your e-mail address'},
                {'id': 'name', 'help': 'Your full name'},
                {'id': 'age', 'help': 'Your age (you must be over 16)'}
            ]
            for (let i = 0; i < helpText.length; i++) {
                (() => {
                   let item = helpText[i]
                   document.getElementById(item.id).onfocus = () => {
                       showHelp(item.help)
                   }
                })()
            }
        }
        setupHelp()
    </script>
    ```

    

- **跨域**

  1. 同源策略

     是一种约束，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS CSRF 等攻击

     所谓同源是指 "协议 + 域名 +端口" 三者相同，即便两个不同的域名指向同一个 IP 地址，也非同源

  2. 同源策略限制内容有：

     - Cookie LocalStorage IndexedDB 等存储性内容
     - DOM 节点
     - ajax 请求发送后，结果被浏览器拦截了

  3. 有 3 个标签是允许跨域加载资源

     ```HTML
     <img src="url" />
     <link href="url">
     <script src="url"></script>
     ```

     

  4. 什么是跨域？

     当协议、子域名、主域名、端口号中任意一个不同，都是不同域，当不同域之前相互请求资源时就是跨域

  5. 特别说明：

     - 如果协议和端口号造成的跨域问题，前端是无力解决的
     - 跨域并不是请求发不出去，请求能够发出去，服务端也能收到请求并且能正常返回结果，只是返回结果被浏览器的安全机制拦截了
     - 在跨域问题上，仅仅是通过 URL 的首部来识别而不会根据域名对应的 IP 地址是否相同来判断；URL 的首部可以理解为 协议、域名、端口

  6. 几种跨域方式及实现原理：[https://juejin.cn/post/6844903767226351623#heading-1](https://juejin.cn/post/6844903767226351623#heading-1)

  7. 利用 Jsonp 实现跨域

     - 原理：利用`script`标签没有跨域限制的漏洞，动态创建`script`标签，网页可以得到从其他来源动态产生的 JSON 数据，`jsonp`请求一定需要对方服务器做支持才可以
     - `jsonp`与`ajax`相同点都是客户端向服务端发送请求，从服务端获取数据的方式；但是`ajax`属于同源策略，而`jsonp`属于非同源策略（跨域请求）
     - `jsonp`优缺点：优点就是简单兼容性好，可以用于解决主流浏览器的跨域数据访问的问题；缺点就是仅支持`GET`请求，有局限性，不安全可能会遭到 XSS 攻击

     ```javascript
     const MyJsonp = ({url, params, callback}) => {
         return new Promise((resolve, reject) => {
             let script = document.createElement('script')
             window[callback] = (data) => {
                 reslove(data)
                 document.body.removeChild(script)
             }
             params = {...params, callback}
             let arr = []
             for (let key in parmas) {
                 if (params.hasOwnProperty(key)) {
                     arr.push(`${key}=${params[key]}`)
                 }
             }
             if (arr.length) {
                 script.src = `${url}?${arr.join('&')}`
             }
             document.body.appendChild(script)
         })
     }
     MyJsonp({
         url: 'https://www.zunshe.net/say',
         params: {userId: '1226', username: '小一'},
         callback: 'show'
     }).then(res => {
         console.log(res)
     }).catch(err => {
         console.log('err=', err)
     })
     ```

     ```javascript
     const MyAjax = (url) => {
         return new Promise((reslove, reject) => {
             const xhr = XMLHttpRequest?XMLHttpRequest():new ActiveXObject('Mscrosoft.XMLHttp')
             xhr.open('GET', url, false)
             xhr.setRequestHeader('Accept', 'application/json')
             xhr.onreadystatechange = () => {
                 if (xhr.readyState !== 4) return false
                 if (xhr.status === 200 || xhr.status === 304) {
                     reslove(xhr.responseText)
                 } else {
                     reject(new Error(xhr.responseText))
                 }
             }
             xhr.send()
         })
     }
     ```

     

- **原型链**

  深度解析原型中的各个难点：[https://hub.fastgit.org/KieSun/Dream/issues/2 ](https://juejin.cn/post/6844903767226351623#heading-1)

  聊聊`new`操作符：[https://hub.fastgit.org/KieSun/Dream/issues/14 ](https://hub.fastgit.org/KieSun/Dream/issues/2)

  万物皆空`JavaScript`原型：[https://juejin.cn/post/6844903567325659144](https://juejin.cn/post/6844903567325659144)

  1. 所有对象都有一个属性`__proto__`指向它的原型对象

  2. 每个对象的原型都可以通过`constructor`指向它的构造函数，构造函数也可以通过`prototype`指向它的原型

  3. `prototype`属性是一个显式属性，只有函数才拥有该属性，基本上所有的函数都有着属性，但是也有例外：

     ```javascript
     let func = Function.prototype.bind()
     console.log('特殊函数的__proto__', func.__proto__) // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, …}
     console.log('特殊函数的prototype', func.prototype) // undefined
     
     let fn = () => {}
     console.log('箭头函数的__proto__', fn.__proto__) // ƒ () { [native code] }
     console.log('箭头函数的prototype', fn.prototype) // undefined
     ```

     <!-- prototype 如何产生的？ -->

     ```javascript
     // 当我们声明一个函数时，这个属性就被自动创建
     function Fn () {}
     console.log(fn.prototype) // {constructor: f}
     // prototype 是一个显式属性，并且这个属性的值是一个对象（就是原型对象）只有一个属性 constructor
     // constructor 对应构造函数，也就是 Fn
     ```

  4. 所有函数都可以通过`__proto__`指向`Function`对象

  5. 所有对象都可以通过`__proto__`指向`Object`对象

  6. 对象之间通过`__proto__`连接起来，称之为原型链。当前对象上不存在的属性可以通过原型链一层层往上找，直到顶层`Object`对象，再往上就是`null`

     <!-- 实例对象的 __proto__ 如何产生的？ -->

     ```javascript
     // 当我们使用 new 操作符时，生成的实例对象就拥有了 __proto__ 隐式属性
     // 在 new 的过程中，新的对象被添加了 __proto__ 并连接到了构造函数的原型上
     function Func (Con, ...args) {
         let obj = {} // 创建个空对象
         // obj.__proto__ = Con.prototype // ES5写法
         Object.setPrototypeOf(obj, Con.prototype) // 连接到原型 ES6写法
         let result = Con.apply(obj, args) // 绑定 this，执行构造函数
         // 确保 new 出来的是个对象
         return result instanceof Object ? result : obj
     }
     // __proto__ 是每个对象都有点隐式原型属性，指向了创建该对象的构造函数的原型
     // 其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，并不能访问，因此才使用 __proto__ 来访问
     ```

     **因为`JavaScript`中没有类的概念，为了实现类继承的方式，通过`__proto__`将对象和原型联系起来组成了原型链，得以让对象访问到不属于自己的属性**

     ```javascript
     // 例子1
     function Test1 (name) {
         this.name = name
     }
     Test1.prototype.sayName = () => {
         console.log(this.name)
     }
     const t1 = new Test1('liuliu')
     console.log(t1.name) // liuliu
     t1.sayName() // liuliu
     // 通过例子1说明：new 通过构造函数 Test1 创建出来的实例可以访问构造函数中的属性，也能访问到构造函数原型链中的属性；也就是说，通过 new 操作符实例与构造函数通过原型链连接了起来
     
     // 例子2
     function Test2 (name) {
         this.name = name
         return null
     }
     const t2 = new Test2('yiyi')
     console.log(t2.name) // yiyiy
     // 通过例子2说明：构造函数如果返回原始值（String, Number, null, undefined, Boolean, NaN, Symbol, BigInt）,那么这个返回值毫无意义；如果返回值为对象，那么这个返回值将会被正常使用
     ```

     <!-- 关于 constructor -->

     - `constructor`是一个**公有且不可枚举的属性**；一旦改变了函数的`prototype`，那么新对象就会没有这个属性（当然可以通过原型链获取到`constructor`）
     - `constructor`作用：让实例对象知道是哪个函数构造了它；如果想给某些类库中的构造函数增加一些固定的方法，就可以通过`xxx.constructor.methond`来扩展

  7. 注意点：

     - 对于实例对象来说，都是通过`new`产生的，无论是`function Foo () {}`还是`let obj = {}`
     - 对已创建一个对象来说，更推荐使用字面量的方式来创建对象，因为使用`new Object()`的方式创建的对象需要通过作用域链一层层找到`Object`，但是使用字面量的方式创建对象就没有这个问题
     - `function`就是一个语法糖，内部等同于`new Function()`
     - 字面量声明对象其实内部也是使用了`new Object()`

  8. **小结：**

     - Object 是所有对象的爸爸，所有的对象都能通过`__proto__`找到它
     - Function 是所有函数的爸爸，所有的函数都能通过`__proto__`找到它
     - Object.prototype 和 Function.prototype 是两个特殊的对象，它们由引擎来创建的
     - 除了以上的两个特殊对象，其他的对象都是通过构造器`new`出来的
     - 对象的`__proto__`指向原型，`__proto__`将对象和原型连接起来组成了原型链

     

- **继承的方式**

  1. 原型链继承

     - 优点：父类方法可以复用
     - 缺点：父类的所有 *引用属性* 会被所有子类共享，更改一个子类的引用类型属性，其他子类也会受影响；子类型实例不能给父类型构造函数传参

     ```javascript
     // 父类
     function Parent () {
         this.isShow = true
         this.info = {
             name: 'liuliu',
             age: 18
         }
     }
     Parent.prototype.getInfo = function () {
         console.log(this.isShow) // true
         console.log(this.info)
     }
     // 子类
     function Child () {}
     // 将子类的 prototype（原型对象） 对象指向父类的实例对象
     Child.prototype = new Parent() // 重点代码
     // 注意点：将子类新的 prototype（原型对象）加上 constructor 属性，并将这个属性只会原来的构造函数
     Child.prototype.constructor = Child
     let child = new Child()
     child.info.gender = '女'
     console.log(child.isShow) // true
     child.getInfo() // {name: 'liuliu', age: 18, gender: '女'}
     // instanceof 判断元素是否在另一个元素的原型链上
     console.log('instanceof', child instanceof Parent) // true
     ```

  2. 借用构造函数继承

     - <u>重点：用`call`和`apply()`将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行---复制）</u>
     - 优点：可以在子类构造函数中向父类传参数；父类的引用属性不会被共享
     - 缺点：子类不能访问父类原型上定义的方法（即不能访问`Parent.prototype`上定义的方法），因此所有方法属性都写在构造函数中，每次创建实例都会初始化

     ```javascript
     // 父类
     function Parent (name) {
         this.isShow = true
         this.info = {
             name
         }
     }
     Parent.prototype.sayName = function () {
         console.log(this.name)
     }
     // 子类
     function Child (name) {
         // 继承自 Parent，并传参数
         Parent.call(this, name) // 重点
         // 实例属性
         this.age = 18
     }
     let child1 = new Child('yiyi')
     child1.isShow = false
     child1.info.gender = '男'
     console.log(child1.info) // {name: 'yiyi', gender: '男'}
     console.log(child1.isShow) // false
     console.log(child1 instanceof Parent) // false
     // child1.sayName() // 报错：Uncaught TypeError: child1.sayName is not a function
     let child2 = new Child('xiaoyi')
     console.log(child2.isShow) // true
     console.log(child2.info) // xiaoyi
     ```

  3. 组合继承（常用）

     <!-- 组合原型链继承和借用构造函数继承，将两者的优点结合了起来 -->

     <u>基本思路：就是使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性，这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性</u>

     - 父类的方法可以复用
     - 可以再`Child`构造函数中想`Parent`构造函数传参数
     - 父类构造函数中的引用属性不会被共享

     ```javascript
     // 父类
     function Parent (name) {
         this.name = name
         this.colors = ["red", "blue", "yellow"]
     }
     Parent.prototype.sayName = function () {
         console.log('Parent.prototype.sayName方法', this.name)
     }
     function Child (name, age) {
         // 继承父类属性
         Parent.call(this, name) // 借用构造函数模式
         // 实例属性
         this.age = age
     }
     // 继承父类方法
     Child.prototype = new Parent() // 原型链模式
     Child.prototype.constructor = Child
     let child1 = new Child('乌拉西', 18)
     child1.colors.push('pink')
     console.log(child1.colors) // ["red", "blue", "yellow", "pink"]
     console.log(child1.age) // 18
     child1.sayName() // 乌拉西
     let child2 = new Child('麻辣鸡', 19)
     console.log(child2.colors) // ["red", "blue", "yellow"]
     console.log(child2.age) // 19
     child2.sayName() // 麻辣鸡
     console.log(child2 instanceof Parent) // true
     ```

     

  4. 原型式继承

     <!-- 其实就是对参数对象的一种浅复制 -->

     - 优点：父类方法可复用
     - 缺点：父类的引用会被所有子类共享；子类实例不能向父类传参；

     ```javascript
     // 封装一个函数容器，用来输出对象和承载继承的原型
     function objectCopy (obj) {
         function Fn () {}
         Fn.prototype = obj // 继承传入的参数
         return new Fn()
     }
     // ES5的 Object.create() 方法在只有第一个参数时，与这里的 objectCopy() 方法效果相同
     let person = {
         name: '阿柳',
         age: 18,
         firends: ['丹丹', '璐璐'],
         sayName: function () {
             console.log(this.name)
         }
     }
     let person1 = objectCopy(person)
     person1.name = '柳柳'
     person1.firends.push('一一')
     person1.sayName() // 柳柳
     let person2 = objectCopy(person)
     person2.name = 'yangliu'
     person2.firends.push('小一')
     person2.sayName() // yangloiu
     console.log('person=', person) // age: 18 firends: (4) ['丹丹', '璐璐', '一一', '小一'] name: "阿柳" sayName: ƒ ()
     ```

     

  5. 寄生式继承

     - 使用原型式继承对一个目标对象进行浅复制，增强这个前渎职的能力

     ```javascript
     function objectCopy (obj) {
         function Fun () {}
         Fun.prototype = obj
         return new Fun
     }
     function createAnother (original) {
         let clone = objectCopy(original)
         clone.getName = function () {
             console.log(this.name)
         }
         return clone
     }
     let person = {
         name: 'wulaxi',
         firends: ['Jack', 'Rose']
     }
     let person1 = createAnother(person)
     person1.firends.push('Tony')
     person1.getName() // wulaxi
     let person2 = createAnother(person)
     console.log(person2.firends) // ['Jack', 'Rose', 'Tony']
     ```

     

  6. 寄生组合继承

     <!-- 寄生组合继承可以算是**引用类型继承**的最佳模式 -->

     - 优点：只调用一次父类构造函数；`Child`可以向`Parent`传参；父类方法可以复用；父类的引用属性不会被共享

     ```javascript
     // 父类
     function Parent (name) {
         this.name = name
         this.firends = ["rose", "lily", "tom"]
     }
     Parent.prototype.sayName = function () {
       console.log(this.name);
     }
     function createObj (obj) { // createObj 就是 Fn 实例的另一种表示方法
         function Fn () {}
         Fn.prototype = obj
         return new Fn()
     }
     function inheritPrototype (child, parent) {
         let prototype = createObj(parent.prototype) // 创建对象
         child.prototype = prototype // 复制对象
         prototype.constructor = child // 增强对象，一定要修复实例
     }
     function Child (name, age) {
         Parent.call(this, name) // 继承了父类构造函数的属性
         this.age = age
     }
     inheritPrototype(Child, Parent)
     Child.prototype.sayAge = function () {
         console.log(this.age)
     }
     let child1 = new Child('小一', 21)
     child1.sayAge() // 21
     child1.sayName() // 小一
     child1.firends.push('lisa')
     console.log('child1', child1.firends) // ['rose', 'lily', 'tom', 'lisa']
     let child2 = new Child('阿柳', 18)
     child2.sayAge() // 18
     child2.sayName() // 阿柳
     console.log(child2.firends) // ['rose', 'lily', 'tom']
     ```

  7. class 实现继承

     ```javascript
     class Animal {
         // constructor 方法---构造方法
         constructor(name) {
             this.name = name // this 关键字代表实例对象
         }
         getName() {
             return this.name
         }
     }
     class Dog extends Animal {
         constructor(name, age) {
             super(name)
             this.age = age
         }
     }
     ```




- **函数柯里化**

  什么叫函数柯里化？其实就是将使用多个参数的函数转化成一系列使用一个参数的函数的技术

  ```javascript
  function add (a, b, c) {
      return a + b + c
  }
  add(1, 2, 3)
  let addCurry = curry(add)
  addCurry(1)(2)(3)
  // 实现 curry 函数，使函数从一次调用传入多个参数变成多次调用每次传一个参数
  function curry (fn) {
      let judge = (...args) => {
          if (args.length == fn.length) return fn(...args)
          return (...args1) => judge(...args, ...args1)
      }
      return judge
  }
  ```

- **偏函数**

  什么是偏函数？偏函数就是将一个`n`参的函数转换成固定`x`参的函数，剩余参数`(n - x)`将在下次调用全部传入。

  ```javascript
  function add (a, b, c) {
      return a + b + c
  }
  let addPartial = partial(add, 1)
  addPartial(2, 3)
  function partial (fn, ...args) {
      return (...args1) => fn(...args, ...args1)
  }
  ```

  

- **数组去重**

  ```javascript
  // 利用数组 indexOf
  const unique1 = (arr) => {
      let newArr = []
      for (let i = 0; i < arrl.length; i++) {
       	if (newArr.indexOf(arr[i]) === -1) {
              newArr.push(arr[i])
          }   
      }
      return newArr
  }
  // 利用数组 includes
  const unique2 = (arr) => {
      let newArr = []
      for (let i = 0; i < arr.length; i++) {
          if (!newArr.includes(arr[i])) {
              newArr.push(arr[i])
          }
      }
      return newArr
  }
  // 利用 ES6 Set 数据结构（其成员值的唯一性）
  // Array.from() 方法可以将类数组对象和可迭代对象转为数组
  const unique3 = (arr) => return Array.form(new Set(arr)) // [...new Set(arr)]
  // 利用对象属性的特性
  const unique4 = (arr) => {
      let newArr = []
      let obj = {}
      for (let i = 0; i < arr.length; i++) {
          if (!obj[arr[i]]) {
              obj[arr[i]] = 1
              newArr.push(arr[i])
          }
      }
      return newArr
  }
  // JSON 数组去重
  const uniqueJSON = (arr, key) => {
      let result = [arr[0]]
      for (let i = 0; i < arr.length; i++) {
          let item = arr[i]
          let flag = false
          for (let j = 0; j < result.length; j ++) {
              if (item[key] == result[j][key]) {
                  flag = true
                  break;
              }
          }
          if (!flag) result.push(item)
      }
      return result
  }
  // 数组去重，过滤掉 false undfined null "0" 0 NaN
  const uniqueSpecial = arr => {
      return arr.filter((val, index, selfArr) => {
          return (!(!val || val === "0")) && (selfArr.indexOf(val) === index)
      })
  }
  
  ```

  

- **数组扁平化**

  ```javascript
  let arr = [1, [[2], [3, 4, [5, 6]]], [], 7]
  // ES10 flat() 方法
  let arrFlat1 = arr.flat(Infinity)
  console.log(arrFlat1) // [1, 2, 3, 4, 5, 6, 7]
  
  // 利用正则表达式
  // 先序列化
  let strFlat = JSON.stringify(arr)
  let arrFlat2 = strFlat.replace(/(\[|\])/g, '').split(',').map(Number)
  // .map(Number) 方法可以将字符串数组变成数字数组
  console.log(arrFlat2) // [1, 2, 3, 4, 5, 6, 7]
  
  // 利用递归
  const Flatten = (arr) => {
      let result = []
      arr.forEach(item => {
          // 判断数组实例：可以用 Array.isArray(param)，可以用 instanceof 判断
          if (item instanceof Array) {
              // 合并数组：可以用数组的 cancat 方法实现，也可以用 push+扩展运算符...实现
              result.push(...Flatten(item))
          } else {
              result.push(item)
          }
      })
      return result
  }
  ```

  

------

# **Vue 知识点**

参考文档：

- [Vue 渐进式JavaScript 框架](https://segmentfault.com/a/1190000012692321)

- [简单通俗的理解Vue3.0中的Proxy](https://segmentfault.com/a/1190000021991591)

- [实现双向绑定Proxy比defineproperty优劣如何?](https://juejin.cn/post/6844903601416978439#heading-9)

- [vue组件间通信六种方式](https://segmentfault.com/a/1190000019208626)

- [Vue.nextTick 的原理和用途](https://segmentfault.com/a/1190000012861862)

  

- **`new Vue()`做了什么？**

  `new Vue()`创建了一个`vue`的实例，其内部执行了根实例的初始化过程

  具体过程：

  1. 选项合并
  2. `$children $refs $slots $createElement`等实例属性的方法初始化
  3. 自定义事件的处理
  4. 数据响应的处理
  5. 生命周期钩子函数的调用（`beforeCreate` `created`）
  6. 可能的挂载

  总结：<u>`new Vue()`创建了根实例并准备好了数据和方法，未来执行挂载时，此过程还会递归的应用于子组件上，最终形成一个紧密的组件实例</u>

  

- **`Vue.use()`干什么的？原理是什么？**

  `Vue.use()`是用来使用插件的，可以在插件中扩展全局组件、指令、原型方法

  具体过程：

  1. 检查插件是否注册成功，若已注册，则直接跳出
  2. 处理参数，将第一个参数之后的参数归集并在首部塞入`this`上下文
  3. 执行注册的方法，调用定义好的`install`方法，传入处理的参数，若是没有`install`方法并IQ额插件本身为`function`，则直接进行注册

  原理步骤：

  1. 插件不能重复加载，`install`方法的第一个参数是`vue`的构造函数，其他参数是`Vue.set()`中除了第一个参数的其他参数。代码：`args.unshift(this)`

  2. 调用插件的方法，代码：`typeof plugin.install === 'function'`

  3. 插件本身是一个函数，直接让函数执行，代码：`plugin.apply(null, args)`

  4. 缓存插件，代码：`installedPlugins.push(plugin)`

     

- **`Vue.set()`方法是如何实现的？**

  `Vue.set()`可以触发更新，是因为我们给对象和数组本身加了`dep`属性，当给对象新增不存在的属性则触发对象依赖的`watcher`去更新，当修改数组索引时我们调用数组本身的`splice`方法去更新数组

  官方定义：<u>`Vue.set(object, key, value)`</u>

  1. 如果是数组，调用重写的`splice`方法更新视图，代码：`target.splice(key, 1, val)`
  2. 如果是对象，将属性定义成响应式的`defineReactive(ob.value, key, val)`
  3. 如果不是响应式的也不需要将其定义在`data`中

  

- **`Vue.nextTick()`原理**

  官方说明：`Vue.nextTick([callback,context])` 在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新之后的DOM 

  参考文档：[https://segmentfault.com/a/1190000012861862 ]()

  异步说明：`Vue`实现响应式并**不是数据发生变化之后`DOM`立即变化**，而是按照一定的策略进行`DOM`的更新。简单来说，`Vue`在修改数据后，视图不会立刻更新，而是等**同一事件循环**中的所有数据变化完成之后，再统一进行视图更新

  事件循环：同步代码执行 -----> 查找异步队列，推入执行栈，执行`Vue.nextTick[事件循环1]` -----> 查找异步队列，推入执行栈，执行`Vue.nextTick[事件循环2]`......

  异步执行的机制：

  1. 所有同步任务都在主线程上执行，形成一个***执行栈***
  2. 主线程之外，还训在一个***任务队列***，只要异步任务有了运行结果，就在***任务队列***中置放一个事件
  3. 一旦***执行栈***中的所有同步任务执行完毕，系统就会读取***任务队列***，查看里面有哪些事件，那些对应的异步任务，于是结束等待状态，进入***执行栈***，开始执行
  4. 主线程不断重复上面的第三步

  

- **`Vue`中模板编译的原理**

  如何将`template`转化成`render`函数，默认`.vue`文件中的`template`处理是通过`vue-loader`来进行出路的并不是通过运行时的编译

  1. 通过大量正则，解析`template`转化成`ast`语法树

  2. ``optimize`过程，标记静态节点，后`diff`过程跳过静态节点，提升性能

     ```javascript
     // 源码解析
     const ast = parse(template.trim(), options)
     if (options.optimize !== false) optimize(ast, options) // 优化代码，标记静态节点
     const code = generate(ast, options) // 生成代码
     ```

     

  3. 将`ast`生成`render`函数方法，返回的是`虚拟DOM`。`render`方法里面通过`generate`函数转化为一串`js`语法的字符串，再通过模板引擎生成`虚拟DOM`

  4. 通过`虚拟DOM`生成真实的`dom`替换原来的节点

  模板引擎的实现原理就是`new Function + with`来实现的

  *`vue-loader`中处理`template`属性主要靠的就是`vue-template-complier`*

  ```javascript
  // vue-loader
  // template ===> ast ===> codeGen ===> with + function 实现生成 render 函数
  let { ast, render } = VueTemplateComplier.complie(`<div>{{testValue}}</div>`)
  console.log(ast, render)
  // render 函数执行完毕后生成的是 虚拟DOM
  ```

  <!-- vue.js 与 vue.runtime.xxx.js 的区别： -->

  ```javascript
  import Vue from 'vue'
  import App from './App.vue'
  // 关闭vue的生产提示
  Vue.config.productionTip = false
  /* 
  关于不同版本的Vue：
  	1.vue.js与vue.runtime.xxx.js的区别：
  		(1).vue.js是完整版的Vue，包含：核心功能+模板解析器。
  		(2).vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。
  	2.因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用template配置项，需要使用 render 函数接收到的createElement函数去指定具体内容。
  */
  
  // 创建Vue实例对象---vm
  new Vue({
  	el:'#app',
  	// render函数完成了这个功能：将App组件放入容器中
    	render: h => h(App),
  	// template:`<App></App>`,
  	// components:{App},
  })
  ```

  

- **`Vue`中的`data`除了根节点外的为什么要是一个函数？**

  同一个组件被复用多次，就会创建多个实例。这些实例都用的同一个构造函数，如果data是个对象，对象属于引用类型，所有组件都会共用这个对象，会影响到所有的实例。

  为了保证组件间数据的独立性，要求每个data函数返回对象，就可以创建互不干扰的新对象。

  

- **`Vue`中`key`的作用和工作原理**

  官方回答：`key` 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。 

  ```javascript
  // 面试题：react vue 中的 key 有什么作用？
  // 在虚拟 DOM 中，key 是虚拟 DOM 对象的标识，当数据发生变化时，vue 会根据【新数据】生成【新的虚拟DOM】，随后 vue 进行【新虚拟DOM】与【旧虚拟DOM】的差异进行比较
  // 比较规则：a. 旧虚拟DOM中找到与新虚拟DOM相同的key，若虚拟DOM中内容没变，直接使用之前旧虚拟DOM生成的真实DOM；若虚拟DOM中的内容变了，则生成新的真实DOM随后替换掉页面中之前的真实DOM。b. 旧虚拟DOM中未找到与新虚拟DOM相同的key，则创建新的真实DOM随后渲染到页面中
  ```

  ![关于key作用](D:\study\Images\关于key作用.png)

  1. `key`的作用主要是为了高效的更新`虚拟DOM`，其原理是`vue`在`patch`过程中通过`key`可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个`patch`过程更加高效，减少了`DOM`操作量，提高性能

  2. 另外，若是不设置`key`还可能在列表更新的时候引发一些隐藏的`bug`

  3. `vue`中在使用相同标签名元素的过渡切换时，也会使用到`key`属性，其目的也是为了让`vue`可以区分它们，否则`vue`只会替换是内部属性而不会触发过渡效果

     

- **`Vue`生命周期**

  总共分为 8 个阶段：创建前后、挂在前后、更新前后、销毁前后

  1. 创建前后：
     - `beforeCreate`阶段：`vue`实例的挂在元素`el`和数据对象`data`都为`undefined`，还未初始化；在当前阶段`data` `methods` `computed` `watch` 上的数据和方法都不能被访问
     - `created`阶段：`vue`实例的数据对象`data`有了，但是元素`el`还是没有，可以做一些初始数据的获取；在当前阶段无法操作`DOM`元素，如果非要操作可以通过`vm.$nextTick`来访问
  2. 挂在前后：
     - `beforeMount`阶段：`vue`实例的`el`和`data`都初始化好了，但还是挂载之前为`虚拟DOM`节点；当前阶段的`虚拟DOM`已经创建完成，即将开始渲染，此时也是可以对数据进行更改，但是不会触发`unpdated`（更新）
     - `mounted`阶段：`vue`实例挂在完成；当前阶段真实的`DOM`挂载完毕，数据完成双向绑定，可以访问到`DOM`节点，使用`$refs`属性对`DOM`进行操作，注意：**该阶段不保证子组件的`DOM`也挂载完毕**
  3. 更新前后：
     - `beforeUpdate`阶段：响应式数据更新时调用，发生在`虚拟DOM`打补丁之前，适合在更新前访问现有的`DOM`，比如手动添加事件监听；可以在当前阶段更改数据，但是不会造成重渲染
     - `updated`阶段：`虚拟DOM`重新渲染和打补丁以后调用，组成新的`DOM`已经更新好了，避免在这个钩子函数中操作数据，防止死循环；当前阶段组件的`DOM`已经完成更新，要注意的是避免在此期间更改数据，因为可能导致无限循环的更新
  4. 销毁前后：
     - `beforeDistory`阶段：实例销毁前调用，实例还是可以用，`this`能获取到实例，常用于销毁定时器，解绑事件；在当前阶段实例完全可以被调用，我们介意在这时进行善后收尾工作，比如清除定时器之类的 
     - `distoryed`阶段：实例销毁后调用，调用后所有事件监听会被移除，所有的子实例都会被销毁。说明：当前阶段组件已被拆解，数据绑定被销毁，监听被移除，子实例也统统被销毁，访问不了`this`

  补充说明：

  * 第一次页面加载时会触发：`beforeCreate` ---> `created` ---> `beforeMount` ---> `mounted`

  * `created`实例已经创建完成，因为它是最早触发的原因可以进行一些数据资源的请求。(服务器渲染支持 created 方法)

  * mounted 实例已经挂载完成，可以进行一些 DOM 操作。(接口请求)

    

- **生命周期钩子函数是如何实现的？**

  `Vue`的生命周期钩子函数就是回调函数，当创建组件实例的过程中会调用对应的钩子方法

  其内部主要是使用`callHook`方法来调用对应的方法。核心是一个发布订阅模式，将钩子订阅好（内部采用数组的方式存储），在对应的阶段进行发布

  

- **`Vue`父组件和子组件生命周期钩子函数的执行顺序**

  第一次页面加载时会触发 `beforeCreate` `created` `beforeMount` `mounted` 钩子函数

  渲染过程：父组件挂载完成一定是等子组件都挂载完毕后，才算是父组件挂载完成，因此父组件的`mounted`是在子组件`mounted`之后

  父beforeCreate ---> 父created ---> 父beforeMount ---> 子beforeCreate ---> 子created ---> 子beforeMount ---> 子mounted ---> 父mounted

  注意：<u>父组件等待子组件执行完成后，才会执行自己对应的钩子函数</u>

  <!-- 组件的调用顺序是先父后子，而渲染完成的顺序肯定是先子后父 -->

  <!-- 组件的销毁过程是先父后子，而销毁完成的顺序肯定是先子后父 -->

  

- **`Vue`组件渲染流程**

  1. 组件渲染时都会调用`Vue.extend()`方法，创建一个子组件构造函数

     <!-- Vue.extend()方法：继承 Vue，合并当前组件选项和用户选项，是子组件的构造函数 -->

     <!-- 组件的本质是一个名为 VueComponent 的构造函数，且是 Vue.extend 生成的 -->

     ```javascript
     // 特别注意：每次调用 Vue.extend 时返回的都是一个全新的 VueComponent 构造函数
     // new Vue(options) 配置中，this 指向均是 Vue 实例对象；组件配置中，this 指向均是 VueComponent 实例对象
     // 重要的内置关系：VueComponent.prototype.__proto__ === Vue.prototype
     // 让组件实例对象 (VueComponent) 可以访问到 Vue 原型上的属性和方法
     ```

     <!-- Vue 解析时会帮我们创建一个组件实例对象，即执行：new VueComponent(options) -->

     ![分析Vue与VueComponent的关系](D:\study\Images\分析Vue与VueComponent的关系.png)

  2. 实例化子组件，会将当前传入选项和用户选项合并，然后手动挂载`$mount`，用真实`DOM`替换原来的组件

  3. 每个组件都会创建一个`Watcher`

     

- **`Vue`组件之间的通信**

  参考文档：[https://segmentfault.com/a/1190000019208626](https://segmentfault.com/a/1190000019208626)

  1. 父传子 `props`

  2. 子传父 `$meit` 发布订阅

  3. 事件总线 `EventBus` `$emit/$on` 适用于父子、隔代、兄弟组件通信

     ```javascript
     const EventBus = new Vue()
     EventBus.$emit(`事件名`, data)
     EventBus.$on(`事件名`, data => {})
     // $on 监听事件，有时不确定何时触发，一般会在 created 或 mounted 钩子函数中来监听
     ```

     

  4. `ref `与 `$parent / $children` 使用父子组件通信

     `ref`：如果在普通的 DOM 元素上，引用指向的就是 DOM 元素；如果用在子组件上，引用指向的就是子组件实例

     `$parent / $children`：访问父组件 / 子组件实例

     这两种方法的弊端：无法跨级或兄弟组件间的通信

     

  5. `$attrs / $listeners` Vue2.4新增属性（亮点）

     - `$sttrs`：包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (`class` 和 `style` 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (`class` 和 `style` 除外)，并且可以通过 `v-bind="$attrs"` 传入内部组件——在创建高级别的组件时非常有用，通常配合 inheritAttrs 选项一起使用

     - `$listeners`：包含了父作用域中的 (不含 `.native` 修饰器的) `v-on` 事件监听器。它可以通过 `v-on="$listeners"` 传入内部组件——在创建更高层次的组件时非常有用

       <u>简单来说：`$attr`与`$listeners`是两个对象，`$attr`里存放的是父组件中绑定的**非 props 属性**；`$listeners`里存放的是父组件中绑定的**非原生事件**</u>

       

  6. `provide / inject`（Vue2.2.0新增API）：主要解决了跨级组件间的通信问题；主要是子组件获取上级组件状态，跨级组件间建立了一中主动提供与依赖注入的关系

     注意点：<u>官方文档说明</u>，`provide`和`inject`绑定并不是可响应的，这是刻意为之的，然而若果传入了一个**可监听的对象**，那么其对象的属性还是可响应的

     <!-- 虽说 provide 和 inject 主要为高阶插件/组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！-->

     `provide / inject`怎么实现数据响应式：

     - `provide`祖先组件的实例，然后再子孙组件中朱如意来，这样就可以在子孙组件中直接修改祖先组件实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如`props methods`

     - 使用 Vue2.6 最新 API `Vue.observable`优化响应式`provide`（推荐）

       ![https://segmentfault.com/img/remote/1460000019208634](https://segmentfault.com/img/remote/1460000019208634)

       ```vue
       <template>
       	    <div class="parent">
               <h1>A 组件</h1>
               <button @click="() => changeColor()">改变color</button>
               <ChildrenB />
               <ChildrenC />
           </div>
       </template>
       export default {
       	data () {
               return {
       			color: 'red'
               }
       	},
           // provide () {
          	// 	 return {
       	//		theme: {
       	//			color: this.color // 这种方式绑定的数据并不是可响应的
       	//		} // 即：A 组件的 color 变化后，组件 D E F 不会跟着变
           //   }
           // }
           provide () {
               return {
       			theme: this // 方法1：提供祖先组件的实例
               }
           },
           methods: {
       		changeColor(color) {
       			if (color) {
                   	this.color = color
                 	 } else {
                   	this.color = this.color === "blue" ? "red" : "blue"
                 	 }
               }
           },
       	// 方式2：使用 Vue2.6 新增 API Vue.observable 优化响应式 provide
       	provide () {
               this.theme = Vue.observable({
                   color: 'red'
               })
               return {
                   theme: this.theme
               }
           },
       	methods: {
               changeColor (color) {
                   if (color) {
                       this.theme.color = color
                   } else {
                       this.theme.color = this.theme.color === "blue" ? "red" : "blue"
                   }
               }
           }
       }
       ```

       ```vue
       <template functional>
       	<div class="comp-f">
               <h3 :style="{color: injections.theme.color}">F 组件</h3>
           </div>
       </template>
       export default {
           inject: {
               theme: {
       			// 函数式组件取值不一样
       			default: () => {}
               }
           }
       }
       ```



- **谈谈`Vuex`的理解**

  官方说明：`Vuex`是一个专为`Vue.js`应用程序开发的**状态管理模式**；

  简单来说就是：<u>多组件共享，集中式存储的状态管理模式</u>

  特性：

  1. 采用单向数据流
  2. `state`存放状态；`getters`为`state`计算属性；`mutations`**同步**修改`state`的值；`actions`**异步**修改`state`的值；`modules`可以模块化；
  3. 通过`dispatch`触发`actions`提交的`mutations`；通过`commit`触发`mutations`修改`state`

  插件：Vuex 持久化插件`vuex-persistedstate`，解决了刷新数据消失的问题

  原理：

  1. `vuex`利用`minxin`混入，在`beforeCreate`钩子函数中，将传入的`option`中的`store`赋值给了根实例上的`$store`，并让子组件每一级都查到`$parent`复制给了自身`$store`，实现多组件共享
  2. `vuex`的响应式借助了`vue`的响应式原理，将`state`放入新的`vue`实例的`data`上，将`getters`传递给`computed`实现实时监听级缓存

  

- **`Vue`组件中写`name`选项有哪些好处及作用？**
  1. 可以通过`name`找到对应的组件
  2. 可以通过`name`属性实现缓存功能（配合`keep-alive`）
  3. 可以通过`name`来识别组件（跨级别组件通信时非常重要）

  

- **谈一谈对`Vue`组件化的理解**
  1. 组件化开发能大幅度提高开发效率、测试性、复用性等
  2. 常用组件化技术：属性、自定义事件、插槽等
  3. 降低更新范围，只重新渲染数据变化的组件
  4. 组建的特点：高内聚、低耦合、单向数据流



- **同一组件路由跳转不重新渲染的处理**

  多个页面使用同一个`component`时，默认情况下当着几个页面切换时并不会触发`vue`的`created / mounted`钩子函数

  1. 通过`watch / $route`的变化来处理

  2. 组件内守卫`beforeRouteUpdate`处理

  3. `<router-view>`标签上加上一个唯一的`key`

     

- **`Vue`中`$router`和`$route`的区别**

  1. `$router`是 ***路由实例对象***，包括了路由跳转方法，钩子函数等
  2. `$route`是***路由信息对象***，包括了`path params hash query fullPath matched name`等路由信息参数

- **`Vue.router`路由钩子函数**

  <!-- vue.router 提供的导航钩子主要用来兰姐导航，让它完成跳转或取消 -->

  1. 全局守卫：`beforeEach` `beforeResolve` `afterEach`

     ```javascript
     // 全局守卫：是指路由实例上直接操作的钩子函数，特点是所有路由配置的组件都会触发
     // 简单来说就是触发路由就会触发这些钩子函数，执行顺序：beforeEach、beforeResolve、afterEach
     ```

     - 全局前置守卫`router.beforeEach`：当一个导航触发时，全局前置守卫按照创建顺序调用；守卫是**异步**解析执行，此时导航在所有守卫`resolve`完之前一直处于**等待中**

       ```javascript
       const router = new VueRouter({})
       router.beforeEach((to, from, next) => {
           // to 即将要进入的目标 路由对象
           // from 当前导航正要离开的路由
           // next 一定要调用该方法来 resolve 这个钩子函数，执行效果依赖 next() 方法的调用参数
           // next()：进行管道中的下一个钩子。如果钩子全部执行完了，则导航的状态就是确认状态
           // next(false)：中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置的 form 路由对应的地址
           // next('/') 或者 next({path: '/'})：跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航，你可以向 next 传递任意位置对象，且允许设置诸如 replace: true, name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项
           // next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。
           /* 确保 next 函数在任何给定的导航守卫中都被严格调用一次 */
           /* 确保要调用 next 方法，否则钩子就不会被 resolved */
           if (to.name !== 'Login' && !isAuthenticated) next({name: 'Login'})
           else next()
       })
       ```

     - 全局解析守卫`router.beforeResolve`：在 2.5.0+ 你可以用 `router.beforeResolve` 注册一个全局守卫。这和 `router.beforeEach` 类似，区别是在导航被确认之前，**同时在所有组件内守卫和异步路由组件被解析之后**，解析守卫就被调用

     - 全局后置钩子`router.afterEach`：你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 `next` 函数也不会改变导航本身

       ```javascript
       const router = new VueRouter()
       router.afterEach((to, from) => {
           // 不会接受 next() 函数，也不会改变导航本身
       })
       ```

       

  2. 单个路由独享守卫：`beforeEnter`

     - 写在路由配置中，只有访问到这个路径，才能触发钩子函数

       ```javascript
       const router = new VueRouter({
           routes: [
               {
                   path: '/home',
                   component: Home,
                   beforeEnter: (to, from, next) => {
                       // 全局前置守卫的方法参数是一样的
                   }
               }
           ]
       })
       ```

       

  3. 组件内的路由守卫：`beforeRouteEnter` `beforeRouteUpdate` `beforeRouteLeave`

     ```javascript
     const Foo = {
         template: ``,
         beforeRouteEnter (to, from, next) {
             // beforeRouteEnter 在渲染该组件的对应路由被确认前调用
             // 不能访问 this，因为当守卫执行前，组件实例还没有被创建
             next(vm => {
                 // 可以通过传一个回调给 next 来访问组件实例
                 // 导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。
                 console.log(vm, '通过 vm 访问组件实例')
             })
         },
         beforeRouteUpdate (to, from, next) {
             // 在当前路由改变，但是该组件被复用时调用
             // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转时
             // 由于会渲染同样的 Foo 组件，因此组件实例会被复用，这种情况 beforeRouteUpdate 钩子被调用
             // 可以访问组件实例 this
         },
         beforeRouteLeave (to, from, next) {
             // 导航离开该组件的对应路由时调用
             // 可以访问组件实例 this
             const answer = window.confirm('Do you really want to leave?')
             if (answer) {
                 next()
             } else {
                 // 导航可以通过 next(false) 来取消
                 next(false)
             }
         }
         // 注意点：beforeRouteEnter 是支持给 next 传递回调的唯一守卫；对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经能访问到了，所以不支持传递回调，因为没必要了
     }
     ```




- **完整的导航解析流程**
  1. 导航触发
  2. 在失活的组件里调用
  3. 调用全局的`beforeEach`守卫
  4. 在重用的组件里调用`beforeRouteUpdate`守卫（Vue2.2+）
  5. 在路由配置里面调用`beforeEnter`
  6. 解析异步路由组件
  7. 在被激活的组件里面调用`beforeRouteEnter`
  8. 调用全局的`beforeResolve`守卫（Vue2.5+）
  9. 导航被确认
  10. 调用全局的`afterEach`钩子函数
  11. 触发`DOM`更新
  12. 调用`beforeRouteEnter`守卫中传给`next`的回调函数，创建好的组件实例会作为回调函数的参数传入



- **`keep-alive`的了解**

  如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 `keep-alive` 组件包裹需要保存的组件。 

  `keep-alive`可以实现组件的缓存，当组件切换时不会对当前组件进行卸载

  `keep-alive`包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们

  当组件在`<keep-alive>`内被切换，它的`activated`和`deactivated`这两个生命周期钩子函数将会被对应执行

  *在 2.2.0 及其更高版本中，`activated` 和 `deactivated` 将会在 `<keep-alive>` 树内的所有嵌套组件中触发*

  三个属性：

  1. `include`字符串或正则表达式，只有名称匹配的组件会被缓存
  2. `exclued`字符串或正则表达式，任何名称匹配的组件都不会被缓存
  3. `max`数字，最多可以缓存多个组件实例

  ```html
  <!-- 逗号分割字符串 -->
  <keep-alive include="a, b">
  	<component :is="view"></component>
  </keep-alive>
  <!-- 正则表达式（使用 v-bind） -->
  <kep-alive :include="/a|b/">
  	<component :is="view"></component>
  </kep-alive>
  <!-- 数组（使用 v-bind） -->
  <keep-alive :inclued="['a', 'b']">
  	<component :is="view"></component>
  </keep-alive>
  <!--
      匹配首先检查组件自身的 name 选项；
  	如果 name 选项不可用，则匹配它的局部注册名称（父组件 components 选项的键值）；
      匿名组件不能被匹配；
      keep-alive 不会在函数式组件中正常工作，因为它们没有缓存实例；
  -->
  <!-- max 属性是 Vue2.5.0 新增的，最多可以缓存多个组件实例，一旦达到这个数字，在新实例被创建之前，已缓存组件中最久没有被访问的实力会被销毁 -->
  <keep-alive :max="5">
  	<component :is="view"></component>
  </keep-alive>
  
  ```



- **`v-if / v-show`区别**
  1. `v-if`如果条件不成立不会渲染当前指令所在节点的`dom元素`
  2. `v-show`不管条件是否成立，都会渲染该`dom元素`，只是切换当前`dom元素`的显示或者隐藏
  3. 从原理上说：`v-if`在渲染成`render`函数时是一个三元表达式，根据条件确定是否被编译出来；而`v-show`在渲染成`render`函数时，调用了一个`自定义指令`，在`自定义指令的el`上修改了`style.display`属性实现的



- **`watch / computed`区别**

  原理解析：[https://blog.csdn.net/chenzhizhuo/article/details/101624812](https://blog.csdn.net/chenzhizhuo/article/details/101624812)

  **侦听属性`watch`：**官方说明，`watch`是一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名或者包含选项的对象。`Vue`实例将会在实例化时调用`$watch()`，来遍历`watch`对象的每一个`property`

  <!-- watch 侦听器用来监听 data 中数据的值，只要监听的数据变化了，就会执行相应的函数 -->

  <!-- $watch 用于监听 Vue 实例上的数据变动 -->

  特点：

  1. **不支持缓存**，数据变化就会直接触发相应的函数

  2. 监听数据必须是`data`中声明过或者父组件传递过来的`props`中的数据

  3. `watch`支持**异步**，**一个数据的变化，去影响多个数据**

  4. `watch`默认情况下无法监听对象的变化，如果要监听就是需要进行深度监听，配合`handler`函数和`deep:true`属性

     - 亮点1：因为它只会监听对象的引用地址是否发生了变化，而值不会监听；
     - 亮点2：深度监听对应的函数名必须是**`handler`**，否则无效，因为`watcher`里面对应的是对`handler`的调用

  5. `watch`默认情况下第一次的时候不会去做监听，如果需要在第一次加载的时候去监听，设置属性`immediate: true `

     ```javascript
     const app = new Vue({
         el: '#app',
         data: {
             firstName: '',
             lastName: '',
             obj: {
                 name: '阿柳'
                 age: 18
             }
         },
         watch: {
             firstName (newVal, oldVal) {
                 // 第一个参数是最新的值，第二个参数是输入之前的值
                 console.log(newVal, '---新值')
                 console.log(oldVal, '---旧值')
             },
             // 深度监听
             obj: {
                 handler (newVal, oldVal) {
                     // 同上
                 },
                 deep: true, // 深度监听
                 immediate: true // 立即执行
             },
             // 以字符串的形式监听
             'obj.name': {
                 handler (newVal, oldVal) {
                     // 同上
                 },
                 deep: true, // 深度监听
                 immediate: true // 立即执行
             }
         }
     })
     
     // watch 原理：实际上是调用 $watch(key, handler, options)，也是基于 Watcher
     Vue.prototype.$watch = function (expOrFn, cb, options) {
         const vm = this
         // 渲染 watcher --- 渲染时使用；用户 watcher --- 用户自己写的
         options.user = true
         new Watcher(vm, expOrFn, cb, options)
     }
     // 在 Watcher 类中首先会调用 get() 方法，该方法可以在 vm 上获取传入的 key 值，标记为 oldValue；
     // 同时将当前的 Watcher 存入 Dep.target 进行依赖收集
     // 当页面值发生变化时，会触发 object.defineProperty 中的 set() 方法通知视图更新，视图更新时最终会触发 watcher 类上的 run 方法，该方法会再次执行 get() 方法去拿页面更新后的结果标记为 newValue，最后将新值老值一起传给用户的回调函数执行
     ```

     ### `Watch`源码的工作流程：

     1. 初始化组件上配置的`watcher`属性
     2. 对`watcher`属性可能的写法进行规整，得出`key`和`handler`
     3. 通过`new Watcher`来创建一个基于`key`和`handler`的观察者
     4. `Watcher`的`key`为响应式**`vm`**上的变量，在`watcher.get`的时候，`watcher`订阅了对应`key`的变化，完成响应依赖
     5. 当`key`的值发生了变化，触发`watcher`的更新方法，并执行回调函数`handler`

  

  **计算属性`computed`：**官当说明，计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例

  特点：

  1. **支持缓存**，只有依赖数据发生改变，才会重新进行计算；没有变化时`computed`会从缓存中读取结果

  2. **不支持异步**，当`computed`内有异步操作时无效，无法监听数据变化；`computed`变量可以用于模板渲染

  3. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用`computed`

  4.  如果`computed`属性值是函数，那么默认会走**`get方法`**；函数的返回值就是属性的属性值；

  5. 在`computed`中的属性都有**`get() / set()`方法**，当数据变化时，调用`set()`方法

  6. `computed`内部的函数必须通过**`return`**的方式将结果返回，最好不要在其内部进行赋值操作

     ```javascript
     // 注意：在开发的时候，能够用 computed 实现就有 computed 实现，因为 computed 有缓存作用，提高性能
     // 在需要执行异步请求操作的时候，就必须要用到 watch 侦听器
     const vm = new Vue({
         el: '#app',
         data: {
             firstName: '蒙奇·D·',
             lastName: '卡普'
         },
         computed: {
             // 计算属性是根据 data 中已有的属性计算得到一个新的属性
             fullName () { // fullName 就是一个计算属性，是一个函数，但可以当作属性来使用
                 return this.firstName + this.lastName
             }
         }
     })
     ```

     **注意点：computed 会重新计算的条件**

     1. 存在依赖型数据（放在`data`等对象下的实例数据）
     2. 依赖型数据发生改变

     ### `computed`源码的流程：

     1. 初始化的时候会获取`computed`里的定义

     2. 通过遍历第一步的结果，按照`computed`新的变量名生成`Watcher`实例

     3. `computed`的`watcher`默认是`lazy`模式，所以`new Watcher`的时候不会调用`watcher`实例的`get()`方法

     4. `vue`为`computed`里的每个`key`代理了一个新的 get 方法`createComputedGetter()`，当`render`页面的时候，新的 get 方法调用`computed watcher`实例的默认 get 方法

     5. `computed`执行自定义 get 方法的时候，会判断是否依赖又变动，没有的话，直接取值，否则去执行获取依赖的变量

     6. 获取依赖变量的时候，将`computed`的`watcher`实例订阅到依赖的变量的`Dep`里

     7. 然后再调用计算列的`watcher.depend`将组建的`watcher`实例也订阅到计算列依赖的所有变量的`dep`中

     8. 当变量变化后，会通知`computed`的`watcher`将`dirty`设置为`true`，以及组件的`watcher`更新`dom`

        注意点：

        - `watcher`初始化是不执行的，如果想初始化就执行的话可以配置`immediate`属性设置为`true`
        - 一般情况下不要直接修改`computed`的值，会报错，一般通过`computed`属性自定义`set()`方法，通过改变依赖变量来改变`computed`的值
        - `computed`的属性如果不加入在`dom`中渲染是不会被加入到响应系统的，所以如果只是数据的变动的监听，不映射到`dom`上，请使用`watcher`或者其他方法
        - `watcher`和`computed`属性定义的函数不能使用箭头函数，否则内部**`this`**会指向组件的父环境，比如`window`，导致调用失败



- **MVC 和 MVVM 区别**
  1. MVC 即 **模型 --- 视图 --- 控制器**，传统后端使用的多一些，目的是为了模型和视图能实现代码分离，用户操作都会经过路由处理来调用控制器，再将页面返回给前端
  2. MVVM 即 **模型 --- 视图 --- 视图模型**，`ViewModal`是视图和模型的桥梁，`view`和`modal`没有直接关系，是通过`ViewModal`自动同步的，因此开发者只需要关注业务的逻辑，数据驱动视图，不需要操作`DOM`
  3. 注意点：`vue`并没有完全遵循`MVVM`模式，例如，`$refs`主要提供给`js`程序访问的，并不建议在模板中过度依赖它，因为这就意味着在实例之外去问实例状态，违背了`vue`数据驱动的思想



- **`Vue2.x`响应式数据原理**

  **官方说明：**当你把一个普通的`Javascript`对象传入`Vue`实例作为`data`选项，`Vue`将遍历此对象所有的`property`，并使用`Object.defineProperty`把这些`property`全部转为`getter / setter`

  `Object.defineProperty`是`ES5`中无法shim的特性，这也就是`Vue`不支持`IE8`以及更低版本浏览器的原因

  那么这里的`shim`是什么呢？`shim`可以将新的`API`引入到旧的环境中，而且仅靠旧环境中已有的方法实现

  **`Object.defineProperty`**这个特性是无法使用低级浏览器中的方法来实现的，所以`Vue`不支持`IE8`以及更低版本的浏览器

  <!-- 存在的问题：新增属性、删除属性，界面不会更新；直接通过下标修改数组，界面也不会自动更新 -->

  简单来说就是在改变数据的时候，视图会跟着更新，数据驱动视图的思想

  `Vue`的响应式，核心机制就是**利用了`Object.defineProperty`方法里面的`setter() / getter()`方法的观察者模式来实现的**

  1. `Object.defineproperty`

     这个方法就是在一个对象上定义一个新属性或者改变一个对象现有的属性，并且返回这个对象
  
     ```javascript
     // 在对象中添加一个属性与存取描述符的示例
     let bValue
     let obj = {}
     Object.defineProperty(obj, 'b', { // 给对象 obj 添加 b 属性，并设置 get set 访问器
         get: function () {
             console.log('监听正在获取b')
             return bValue
         },
         set: function (newValue) {
             console.log('监听正在设置b')
             bValue = newValue
         },
         enumerable: true,
         configurable: true
     })
     obj.b = 18 // 这个时候就会调用 set 函数给 bValue 赋值
     console.log(obj.b) // obj.b 获取值时候就会调用 get 函数
     // 打印结果：监听正在设置b ---> 监听正在获取b ---> 18
     
     ```
  
     ```html
     <!-- 极简的 Vue 双向绑定 -->
     <input type="text" id="txt" />
     <span id="sp"></span>
     <script>
     	let txt = document.getElementById('txt')
         let sp = document.getElementById('sp')
         let obj = {}
         // 给对象 obj 添加 msg 属性，并设置 setter 访问器
         Object.defineProperty(obj, 'msg', {
             get: function () {
                 console.log('get val')
             },
             // 设置 obj.msg，当 obj.msg 发生改变时 set 方法将会被调用
             set: function (newVal) {
                 // 当 obj.msg 被赋值时，同时设置给 input/span
                 txt.value = newVal
                 sp.innerText = newVal
             },
             enumerable : true,
             configurable : true
         })
         // 监听文本框的改变，当文本框输入内容时，改变 obj.msg
         txt.addEventListener('keyup', function (event) {
             obj.msg = event.target.value
         })
     </script>
     <!-- Vue 给 data 里所有的属性加上 set/get 这个过程就叫做 Reactive 化 -->
     ```

  2. 观察者模式

     什么是观察者模式？它分为**注册环节**和**发布环节**

     比如我去买芝士蛋糕，但是店家还没有做出来，这时候我又不想在店外面傻傻等着，我就需要隔一段时间来回问问蛋糕做好了没，对于我来说是很麻烦的事情，说不定我就懒得买了

     店家肯定想要做生意，不想流失我这个客户，于是在蛋糕没有做好的这段时间，有客户来，他们就让客户把自己的电话留下，这就是观察者模式中的**注册环节**，然后蛋糕做好了之后，一次性通知所有记录了的客户，这就是观察者模式的**发布环节**
  
     ```javascript
     // 实现一个简单观察者模式的类
     function Observer () {
         this.dep = []
         register (fn) {
             this.dep.push(fn)
         }
         notify () {
             this.dep.forEach(item => item())
         }
     }
     const wantCake = new Observer()
     // 每来一个客户就注册一个想执行的函数
     wantCake.register(() => {console.log('call Joke')})
     wantCake.register(() => {console.log('call Rose')})
     wantCake.register(() => {console.log('call Tony')})
     // 最后蛋糕做好了之后就通知所有的客户
     wantCake.notify()
     ```

  3. 原理解析

     官网解析图：[https://cn.vuejs.org/images/data.png](https://cn.vuejs.org/images/data.png)![https://cn.vuejs.org/images/data.png]()

     - **init 阶段：**`Vue`的`data`的属性都会被`reactive`化，也就是加上`setter / getter`函数
  
       ```javascript
       function defineReactive (obj: Object, key: string, ...) {
           const dep = new Dep()
           Object.defineProperty(obj, key, {
               enumable: true,
               configurable: true,
               get: function reactiveGetter () {
                   // ...
                   deo.depend()
                   return value
                   // ...
               },
               set: function reactiveSetter (newVal) {
                   // ...
                   val = newVal
                   dep.notify()
                   // ...
               }
           })
       }
       class Dep {
           static target: ?Watcher;
       	subs: Array<Watcher>;
           
           depend () {
               if (Dep.target) Dep.target.addDep(this)
           }
       	
           notify () {
               const subs = this.subs.slice()
               for (let i = 0; l = subs.length; i < l; i++) {
       			subs[i].update()
               }
           }
       }
       // 其中这里的 Dep 就是一个观察者类，每一个 data 的属性都会有一个 dep 对象；
       // 当 getter 调用的时候，去 dep 里注册函数
       // setter 的时候，就是去通知执行刚刚注册的函数
       ```

     - **mount 阶段：**
  
       ```javascript
       mountComponent (vm: Component, el: ?Element, ...) {
           vm.$el = el
           // ...
           updateComponent = () => {
               vm._update(vm._render(), ...)
           }
           new Watcher(vm, unpdateComponent, ...)
       }
       class Watcher {
        getter: Function;
  
           // 代码经过简化
           constructor (vm: Component, expOrFn: string | Function, ...) {
               // ...
               this.getter = expOrFn
               Dep.target = this // 注意这里将当前的 Watcher 赋值给了 Dep.target
               this.value = this.getter.call(vm, vm) // 调用组件的更新函数
           }
       }
       ```

       mount 阶段的时候，会创建一个 `Watcher`类的对象

       `Watcher`实际上是连接`Vue`组件和`Dep`的桥梁

       每一个`Watcher`对应一个`vue component`组件

       这里可以看出 `new Watcher`的时候，`constructor`里的`this.getter.call(vm, vm)`函数会被执行

       `getter`就是`updateComponent`，这个函数会调用组件的`render函数`来更新重新渲染

       而`render函数`里，会访问`data`的属性，比如：
  
       ```javascript
       render: function (createElement) {
           return createElement('h1', this.blogTitle)
       }
       // 此时回去调用这个属性 blogTitle 的 getter 函数，即：
       // getter 函数
       get: function reactiveGetter () {
           // ...
           dep.depend()
           return value
           // ...
       },
       // dep 的 depend 函数
       depend () {
       	if (Dep.target) Dep.target.addDep(this)        
       }
       // 在 depend 的函数里，Dep.target 就是 watcher 本身，这里做的事情就是给 blogTitle 注册了 Watcher 这个对象，这样每次 render 一个 vue 组件的时候，如果这个组件用到了 blogTitle，那么这个组件相对应的 Watcher 对象都会被注册到 blogTitle 的 Dep 中，这个过程就叫做依赖收集
       // 收集完所有依赖 blogTitle 属性的组件所对应的 Watcher 之后，当它发生改变的时候，就回去通知 Watcher 更新关联的组件
       ```

     - **更新阶段：**

       当`blogTitle`发生改变的时候，就去调用`Dep 的 notify函数`，然后通知所有的`Watcher`调用`update函数更新`
  
       ```javascript
       notify () {
           const subs = this.subs.slice()
           for (let i = 0; l = subs.length; i < l; i++) {
               subs[i].update()
           }
       }
       ```

       ![https://pic2.zhimg.com/80/v2-cbc890983833db0a0b35841c05f4d3d1_720w.jpg]()

       由上图可以看出`Watcher`是连接 `Vue 组件与 data 属性`的桥梁 

  4. **总结：**

     - **第一步：**组件初始化的时候，先给每一个 **`data`**属性都注册**`getter / setter 方法`**，也就是**`reactive 化`**，然后再**`new`一个自己的`Watcher 对象`**，此时的**`Watcher`**会立即调用组件的**`render 函数`**去生成**`虚拟 DOM`**，在调用**`render`**的时候，就回需要用到**`data 的属性值`**，此时会触发**`getter 函数`**，将当前的**`Watcher 函数`**注册进**`sub`**里

     - **第二步：**当**`data`**属性发生改变之后，就会遍历**`sub`**里所有的**`watcher`**对象，通知它们去重新渲染组件

       <!-- 关于 Observer Dep Watcher -->

     - **`Observer`：**数据的观察者，让数据对象的读写操作都处于自己的监管之下；当初始化实例的时候，会递归遍历`data`，用`Object.defineProperty`来拦截数据

     - **`Dep`：**数据更新的发布者，`get`数据的时候，收集订阅者 ---> `dep.addSub()`，触发`Watcher`的依赖收集 ---> `this.subs.push(sub)`，`set`数据时通知`Watcher` ---> `dep.notify()`，发布更新 ---> `update()`

     - **`Watcher`：**数据更新的订阅者，订阅的数据改变时执行相应的回调函数（更新视图或表达式的值）

  5. **彩蛋**
  
     ```javascript
     // 如果你想要的属性是响应式的，就一定要写在 data 对象里
     // 因为 Vue 只对 data 里的属性做了 reactive 化处理
     const vm = new Vue({
         el: '#app',
         data: {
            a: 1
         }
     })
     // vm.a 是响应式的
     vm.b = 2 // 是非响应式的
     //或者使用 Vue.set(vm.someObject, 'b', 2) 动态添加，这个也是响应式的
     ```




- **`Vue3.x`的响应式数据原理**

  `Vue3.x`一个很重要的改变就是将`ES6`的`Proxy`作为**观察者机制**，取代之前使用的`Object.defineProperty`

  `Object.defineProperty`有以下几个缺陷：

  1. 无法检测数组的变化

     `Object.defineProperty`无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值时不能实时响应。而且使用数组`push / pop / shift / unshift / splice / sort / reverse`等方法是不能触发`set()`方法的，`Vue`中能监听到是因为对这些方法进行了重写

     ```javascript
     let a = {}
     let bValue = 1
     Object.defineProperty(a, 'b', {
         get: function () {
             console.log('getter')
             return bValue
         },
         set: function (newVal) {
             bValue = newVal
             console.log('setter')
         },
         enumerable : true,
       	configurable : true
     })
     a.b = [] // setter
     a.b = [1, 2, 3] // setter
     a.b[1] = 10 // 无输出
     a.b.push(4) // 无输出
     a.b.length = 5 // 无输出
     // 当 a.b 被设置成为数组后，只要不是重新赋值一个新的数组对象，任何对数组内部的修改都不会触发 set() 方法的执行。
     // 所以要想实现数组的双向绑定，则必须通过 Arr = newArr 这样的语句实现
     // 同样常见的数组方法也不会触发 set() 方法的执行，在框架中对这些方法进行了重写才能实现效果
     ```

  2. 只能监听属性，而不是监听对象本身，需要对对象的每个属性进行遍历。对于原本不在对象中的属性难以监听。在`Vue2.x`中，是通过`callback + 遍历 data 对象`来实现对数据的监控，如果属性值也是对象那么需要深度遍历，闲人如果能够劫持一个完整的对象才是更好的选择，而`Proxy`就显示了这方面的优势

  3. 当对象属性增加删除的时候，是监听不到的。比如：`data = {a: 'aaa'}`，这个时候如果我们设置`data.test = 'test'`，`Object.defineProperty`是监听不到的，因为在`observer data`的时候，会遍历已有的每个属性（比如 a）添加`getter / setter`方法，而后面设置的`test`属性并没有机会设置`getter / setter`方法，所以检测不到变化。同样的，删除对象属性的时候，`getter / setter`会跟着属性一起被删除掉，拦截不到变化

  

  `Proxy`是 ES6 原生提供的一个构造函数，MDN 上的解释为：`Proxy`对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。

  什么是代理呢？可以理解为在对象前设置一个`拦截`，当该对象被访问的时候，都必须经过这层`拦截`。

  **注意：** **`Proxy`**是用来操作对象的，代理的目的是为了拓展对象的能力。

  ```javascript
  // const proxyObj = new Proxy(target, handler)
  // target: 所要拦截的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）
  // handler: 一个对象，定义要拦截的行为
  const proxyObj = new Proxy({}, {
      get (target, propKey) {
          return '被我拦截了！Proxy'
      }
  })
  console.log(proxyObj.name) // 被我拦截了！Proxy
  
  // 不允许外部修改对象的 name 属性
  const p = new Proxy({}, {
      set (target, propKey, value) {
          if (propKey === 'name') {
              throw new TypeError('name 属性不允许修改')
          }
          // 不是 name 属性，直接保存
          target[propKey] = value
      }
  })
  p.name = 'proxy' // TypeError: name 属性不允许修改
  p.age = 18
  console.log(p.age) // 18
  ```

  *`Proxy`支持的拦截操作一共有 13 种，详情可以查看 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)*

  *`Reflect` 反射对源数据的属性进行操作，详情可以查看[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect)*

  **使用`Object.defineProperty()` 实现：**
  
  ```javascript
  class Observer {
      constructor (data) {
          // 遍历参数 data 的属性，给添加到 this 上
          for (let key of Object.keys(data)) {
              if (typeof data[key] === 'object') {
                  data[key] - new Observer(data[key])
              }
              Object.defineProperty(this, key, {
                  enumerable: true,
                  configurable: true,
                  get () {
                      console.log('访问了' + key)
                      // 中括号法可以用变量作为属性名，而点方法不可以
                      return data[key]
                  },
                  set (newVal) {
                  	console.log('设置了' + key)
                      console.log('新的' + key + '=' + newVal)
                      if (newVal === data[key]) {
                          return;
                      }
                      data[key] = newVal
                  }
              })
          }
      }
  }
  const obj = {
      name: 'Jack',
      age: 18,
      a: {
          b: 1,
          c: 2
      }
  }
  const app = new Observer(obj)
  app.age = 20
  console.log(app.age)
  app.newPropKey = '新属性'
  console.log(app.newPropKey)
  
  // 上面代码执行结果
  // 设置了age
  // 新的age=20
  // 访问了age
  // 20
  // 新属性 ---> 设置新属性的输出
  ```

  从上面代码可以看到：给对象新增一个属性，内部并没有监听到，新增的属性需要手动再次调用`Object.defineProperty()`进行监听

  这就是为什么`Vue2.x`中检测不到对象属性的添加和删除的原因，内部提供的`$set`就是通过调用`Object.defineProperty()`去处理的

  

  **使用 `Proxy` 替代 `Object.defineProperty()`实现：**
  
  ```javascript
  // 通过 Proxy 代理：拦截对象中任意属性的变化，包括属性值的读写，属性的添加或删除等
  // 通过 Reflect 反射：对源数据的属性进行操作
  new Proxy(data, {
      // 拦截读取属性值
      get (target, prop) {
          return Reflect.get(target, prop)
      },
      // 拦截设置属性值或添加新属性
      set (target, prop, value) {
      	return Reflect.set(target, prop, value)
  	},
      // 拦截删除属性
      deleteProperty (target, prop) {
          return Reflect.deleteProperty(target, prop)
      }
  })
  
  ```
  
  
  
  ```javascript
  const obj = {
      name: 'Rose',
      age: 18,
      a: {
          b: 1,
          c: 2
      }
  }
  const proxyObj = new Proxy(obj, {
      get (target, propKey, receiver) {
          console.log('访问了' + propKey)
          return Reflect.get(target, propKey, receiver)
      },
      set (target, propKey, value, receiver) {
          console.log('设置了', propKey)
          console.log('新的' + propKey + '=' + value)
          Reflect.set(target, propKey, value, receiver)
      }
  })
  proxyObj.age = 21
  console.log(proxyObj.age)
  proxyObj.newPropKey = '新属性proxy'
  console.log(proxyObj.newPropKey)
  
  // 上面代码执行结果
  // 设置了age
  // 新的age=21
  // 访问了age
  // 21
  
  // 设置了newPropKey
  // 新的newPropKey=新属性proxy
  // 访问了newPropKey
  // 新属性proxy
  
  ```
  
  从上面代码可以看到：新增的属性，并不需要重新添加响应式处理，因为`Proxy`是对对象的操作，只要你访问对象，就会走到`Proxy`的逻辑中
  
  **`Reflect`**是一个内置的对象（ES6引入的），它提供拦截`JavaScript`操作方法。将`Object`对象一些明显属于语言内部方法，比如`Object.defineProperty()`放到`Reflect`对象上。修改某些`Object`方法的返回结果，让其变得更合理。

**总结：**

- **`Proxy`**是用来操作对象的，拓展对象的能力；而**`Object.defineProperty()`**是对对象属性进行操作
- `Vue2.x`使用`Object.defineProperty()`实现数据的响应式，但是由于`Object.defineProperty()`是对对象属性的操作，所以需要对对象进行深度遍历去对属性进行操作
- `Vue3.x`使用`Proxy`对对象进行拦截操作，无论是对对象做什么样的操作都会走到`Proxy`的处理逻辑中