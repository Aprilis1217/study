/**
 * VUE 原理性知识点
 */

// 1. 对 SPA 单页面应用的理解，优缺点是什么？
/**
 * SPA 仅在 web 页面初始化时加载相应的 HTML CSS Javascript，一旦加载完成，SPA 不会因为用户的操作而进行重新渲染或跳转；取而代之的是利用路由机制实现 HTML 内容的变化，结合 VUE 这个渐进式框架利用数据驱动试图的变化，避免页面的重新加载渲染
 * 
 * 有点：
 * 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染
 * SPA 相对对服务器压力小
 * 前后端职责分离，架构清晰，前段进行交互逻辑，后端负责数据处理
 * 
 * 缺点：
 * 首屏（初次）加载慢，为实现单页面 web 应用功能及显示效果，需要再加载资源的时候将 JavaScript CSS 统一加载，部分页面按需加载
 * 不利于 SEO 的搜索，由于所有内容都在一个页面中动态替换显示，所以 SEO 上其实有着天然的弱势
 */
/**
 * 优化首屏加载慢：
 * a. 使用 CDN 资源，减小服务器带宽的压力
 * b. 利用 VUE 中的路由懒加载
 * c. 将一些静态 js css 文件放到其他地方（比如 OSS）减小服务器压力
 * d. 按需加载第三方资源，如 UI 组件的按需引入
 * e. 使用 nginx 开启 gzip 减小网络传输的流量大小
 * f. 若首屏为登录页面，可以做成多入口，登录页面单独分离为一个入口
 * g. 使用 uglifyjs-webpack-plugin 插件代替 webpack 自带的 UglifyJsPlugin 插件
 */

// ================================================================================================

// 2. new Vue() 发生了什么？
// new Vue() 创建了一个 vue 的实例，它的内部执行了根实例的初始化过程
// 具体过程：
/**
 * 选项合并 ---> $children $refs $slots $createElement 等实例属性的方法初始化 ---> 自定义事件处理 ---> 数据响应处理 --->
 * 生命周期钩子函数调用（beforeCreate created）---> 可能的挂载
 * 
 * 总结：new Vue() 创建了根实例并准备好了数据和方法，未来执行挂载时，此过程还会递归的应用于的子组件上，最终形成一个紧密关系的组件实例
 */

// ================================================================================================

// 3. Vue.use() 时干什么的？原理是什么？
// Vue.use() 是用来使用插件的，我们可以在插件中扩展全局组件、指令、原型方法
/**
 * a. 检查插件是否注册成功，若已注册，则直接跳出
 * b. 处理参数，将第一个参数之后的参数归集，并在首部塞入 this 上下文
 * c. 执行注册的方法，调用定义好的 install 方法，传入处理的参数，若是没有 install 方法并且插件本身为 function ，则直接进行注册
 */
// 原理步骤：
// 插件不能重复加载，install 方法的第一个参数是 vue 的构造函数，其他参数是 Vue.set 中除了第一个参数的其他参数 代码：args.unshift(this)
// 调用插件的方法，代码：typeof plugin.install === 'function'
// 插件本身是一个函数，直接让函数执行，代码：plugin.apply(null, args)
// 缓存插件，代码：installedPlugins.push(plugin)

// ================================================================================================

// 4. 你对响应式数据的理解
// 根据数据类型来做不同的处理，数组和对象类型的数据如何劫持。
/**
 * a. 对象内部通过 defineReactive 方法，使用 Object.defineProperty() 监听数据属性的 get 来进行数据依赖收集，再通过 set 来完成数据更新的派发
 * b. 数组则通过重写数组方法来实现的，扩展它的 7 个变更方法，通过监听这些方法可以做到依赖收集和更新派发 (push/pop/shift/unshift/splice/reverse/sort)
 */
// 内部依赖收集是怎么做到的，每个属性都拥有自己的 dep 属性，存放它所依赖的 watcher，当属性变化后会通知自己对应的 watcher 去更新

/**
 * 响应流程：
 * a. defineReactive 把数据定义成响应式的
 * b. 给属性增加一个 dep, 用来收集对应的那些 watcher
 * c. 等数据变化进行更新。
 * dep.depend() ---> get 取值：进行依赖收集
 * dep.notify() ---> set 设置时：通知师徒更新
 */
// 这里可以引出性能优化相关的内容： 
// 对象层级过深，性能就会差
// 不需要响应数据的内容就不要放在 data 中
// object.freeze() 可以冻结数据

// ================================================================================================

// 5. Vue 如何检测数组变化？
// 数组考虑性能原因是没有用 defineProperty 对数组的每一项进行拦截，而是选择重写数组方法
// 当数组调用到 push/pop/shift/unshift/splice/reverse/sort 这 7 这个方法的时候，执行 dep.notify() 进行派发通知 watcher 更新
/**
 * 在 Vue 中修改数组的索引和长度是无法监控到的，需要通过 push/pop/shift/unshift/splice/reverse/sort 这 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新，数组中如果是对象数据类型也会进行递归劫持
 * 
 * 说明：那如果想要改索引更新数据怎么办？
 * 可以通过 Vue.set() 方法来进行处理 ---> 核心内部用的是 splice 方法
 * 取出原型方法：const arrayProto = Array.prototype
 * 拷贝原型方法：export const arrayMeathods = Object.create(arrayProto)
 * 重写数组方法：def(arrayMethods, method, function mutator () {})
 * 调用方法时更新试图：ob.dep.notify()
 */

//  ===============================================================================================

// 6. Vue.set() 方法是如何实现的？
// 为什么 Vue.set() 可以触发更新，我们给对象和数组本身都加了 dep 属性，当给对象新增不存在的属性则触发对象依赖的 watcher 去更新，当修改数组索引时我们调用数组本身的 slpice 方法去更新数组
// 官方定义： Vue.set(object, key, value)
/**
 * 如果是数组，调用重写的 splice 方法更新视图。代码：target.splice(key, 1, val)
 * 如果不是响应式的也不需要将其定义在 data 中
 * 如果是对象，将属性定义成响应的 defineReactive(ob.value, key, val)
 */

// ================================================================================================

// 7. Vue 中模板编译原理？
// 如何将 template 转化成 render 函数（这里要注意的是我们在开发时尽量不要使用 template，因为将 template 转化成 render 方法需要再运行时进行编译操作会有性能的损耗，同时引用带有 complier 包 的 vue 体积也会变大）默认 .vue 文件中的 template 处理是通过 vue-loader 来进行处理的并不是通过运行时的编译
/**
 * a. 将 template 模板转化成 ast 语法树 ---> parserHTML
 * b. 对静态语法做静态标记 ---> markUp
 * c. 重新生成代码 ---> codeGen
 */
// 模板引擎的实现原理就是 new Function + with 来进行实现的
// vue-loader 中处理 template 属性主要靠的就是 vue-template-complier

/**
 * vue-loader
 * template => ast => codegen => with + function 实现生成 render 函数
 * let {ast, render} = VueTemplateComplier.complie(`<div>{{testValue}}</div>`)
 * console.log(ast, render)
 * 
 * 模板引擎的实现原理 with + new Function
 * console.log(new Function(render).toString())
 * 
 * 
 * render 函数执行完毕后生成的是 虚拟 DOM
 * with(this){return _c('div', [s(testValue)])}
 * 
 * 生成代码
 * 
 **/

//  * 源码设置：
const ast = parse(template.trim(), options) // 将代码解析成 ast 语法树
if (options.optimize !== false) {
  optimize(ast, options) // 优化代码 标记静态点 标记树
}
const code = generate(ast, options) // 生成代码

// ================================================================================================
// 8. Proxy 与  Object.defineProperty 优劣势
/**
 * Proxy 的优势：
 * a. proxy 可以直接监听对象而非属性
 * b. proxy 可以直接监听数组的变化
 * c. proxy 有多达 13 中拦截方法，不限于 apply ownKeys deleteProperty has 等等是 Object.defineProperty 不具备的
 * d. proxy 返回的是一个新对象，我们可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性来修改
 * e. proxy 作为新标准将受到浏览器厂商重点持续的性能优化
 */

/**
 * Object.defineProperty 的优势：
 * 兼容性好，支持 IE9，而 Proxy 存在浏览器兼容性问题，而且无法用 polyfill 磨平 (Vue3.0 就是利用 proxy 来实现数据响应)
 */

// ================================================================================================

// 9. Vue3.x 响应式数据原理
// Vue3.x 改用 Proxy (只会代理对象的第一层) 替代 Object.defineProperty 
// 因为 Proxy 可以直接监听对象和数组的变化，并且有很多种拦截方法，并且作为新标准将受到浏览器厂商重点持续的性能优化

/**
 * Proxy 只会代理对象的第一层，那么 Vue3.x 是怎么样处理这个问题的呢？
 * 判断当前 Reflect.get 的返回值是否为 object，如果是则在通过 reactive 方法做代理，这样就实现了深度观测
 */

/**
 * 监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？
 * 我们可以判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger
 */

// ================================================================================================

// 10. Vue 生命周期
/**
 * 总共分为 8 个阶段：创建前后、挂载前后、更新前后、销毁前后
 */

// a. 创建前后：
// beforeCreate 阶段：vue 实例的挂载元素 el 和数据对象 data 都为 undefined，还未初始化。说明：在当前阶段 data methods computed watch 上的数据和方法都不能被访问
// created 阶段：vue 实例的数据对象 data 有了，但是元素 el 还是没有。说明：可以做一些初始数据的获取，在当前阶段无法操作 DOM 元素，如果非要操作可以通过 vm.$nextTick 来访问

// b. 挂载前后：
// beforeMount 阶段：vue 实例的 el 和 data 对象都初始化好了，但还是挂载之前为虚拟的 DOM 节点。说明：当前阶段的虚拟 DOM 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，但不会触发 updated (更新)
// mounted 阶段：vue 实例挂载完成，data.message 成功渲染。说明：在当前阶段真实的 DOM 挂载完毕，数据完成双向绑定，可以访问到 DOM 节点，使用 $refs 属性对 DOM 进行操作，注意 该阶段不保证子组件的 DOM 也挂载完

// c. 更新前后：
// beforeUpdate 阶段：响应式数据更新时调用，发生在虚拟 DOM 打补丁之前，适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听。说明：可以在当前阶段进行更改数据，不会造成重渲染
// updated 阶段：虚拟 DOM 重新渲染和打补丁以后调用，组成新的 DOM 已经更新，避免在这个钩子函数中操作数据，防止死循环。说明：当前阶段组件的 DOM 已经完成更新，要注意的是避免在此期间更改数据，因为这可能导致无限循环的更新

// d. 销毁前后：
// beforeDestroy 阶段：实例销毁前调用，实例还可以用，this 能获取到到实例，常用语销毁定时器，解绑事件。说明：在当前阶段实例完全可以被调用，我们介意在这时进行善后收尾工作，比如清除定时器之类的
// destroyed 阶段：实例销毁后调用，调用后所有事件监听会被移除，所有的子实例都会被销毁。说明：当前阶段组件已被拆解，数据绑定被销毁，监听被移除，子实例也统统被销毁，访问不了 this

/**
 * 补充说明：
 * 第一次页面加载时会触发：beforeCreate ---> created ---> beforeMount ---> mounted
 * created 实例已经创建完成，因为它是最早触发的原因可以进行一些数据资源的请求。(服务器渲染支持 created 方法)
 * mounted 实例已经挂载完成，可以进行一些 DOM 操作。(接口请求)
 */

// ================================================================================================

// 11. 生命周期钩子函数是如何实现的？
/**
 * Vue 的生命周期钩子函数就是回调函数，当创建组件实例的过程中会调用对应的钩子方法
 * 其内部主要是使用 callHook 方法来调用对应的方法。核心是一个发布订阅模式，将钩子订阅好（内部采用数组的方式存储），在对应的阶段进行发布
 */

// ================================================================================================

// 12. Vue 的父组件和子组件生命周期钩子函数执行顺序
// 第一次页面加载时会触发 beforeCreate created beforeMount mounted 钩子函数
// 渲染过程：父组件挂载完成一定是等子组件都挂载完成后，才算是父组件挂载完，所以父组件的 mounted 是在子组件 mounted 之后

// 父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted

// 子组件更新过程：
// 影响到父组件：父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated
// 不影响父组件：子beforeUpdate -> 子updated

// 父组件更新过程：
// 影响到子组件：父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated
// 不影响子组件：父beforeUpdate -> 父updated

// 销毁过程：父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed

// 重要：父组件等待子组件完成后，才会执行自己对应的钩子函数

// ================================================================================================

// 13. Vue 中的组件的 data 为什么是个函数？
/**
 * 每次使用组件时都会对组件进行实例化操作，并且调用 data 函数返回一个对象作为组件的数据源。这样可以保证多个组件间数据互不影响
 * 
 * 如果 data 是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证不同组件的实例之间 data 不冲突，data 必须是一个函数
 */

// ================================================================================================

// 14. Vue 组件通信有哪几种方法？
/**
 * a. props / $emit 使用父子组件通信
 * 
 * b. ref 与 $parent / $children 使用父子组件通信
 * ref: 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用的就指向组件实例
 * $parent / $children: 访问父 / 子组件实例
 * 
 * c. EventBus ($emit/$on) 适用于父子、隔代、兄弟组件通信
 * 这种方法通过一个空的 Vue 实例作为事件总线，用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件
 * 
 * d. $attrs / $listeners 使用与 隔代组件通信
 * $attrs: 包含了父作用域中不被 prop 所识别（且获取）的特性绑定（class style 除外）。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定（class style 除外），并且可以通过 v-bind="$attrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用
 * $listeners: 包含父作用域中的（不含 .native 修饰器）v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件
 * 
 * e. provide / inject 适用于隔代组件通信
 * 祖先组件中通过 provide 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决跨组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系
 * 
 * f. vuex适用于父子、隔代、兄弟组件通信
 * vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 vuex 应用的核心就是 store 仓库。store 基本上就是一个容器，它包含着你的应用中大部分的状态(state)
 **/

// ================================================================================================

// 15. 组件中写 name 选项有哪些好处及作用？
/**
 * a. 可以通过名字找到对应的组件
 * b. 可以通过 name 属性实现缓存功能（keep-alive）
 * c. 可以通过 name 来识别组件（跨级组件通信时非常重要）
 */

// ================================================================================================
// 16. $nextTick 原理 ---> https://segmentfault.com/a/1190000012861862
// 异步说明：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按照一定的策略进行 DOM 的更新
// vue 官方文档中，说明 vue 是异步执行 DOM 更新的
/**
 *  异步执行的运行机制：
 * 1. 所有同步任务都在主线程上执行，形成一执行栈
 * 2. 主线程之外，还存在一个 "任务队列"，只要异步任务有了运行结果，就在 "任务队列" 之中放置一个事件
 * 3. 一旦 "执行栈" 中的所有同步任务执行完毕，系统就会读取 "任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈开始执行
 * 4. 主线程不断重复上面的第三步
 */
// 简单来说，Vue 在修改数据后，视图不会立刻更新，而是等 "同一事件循环" 中的所有数据变化之后，再统一进行视图更新
/**
 * 例子：
 * 改变数据
 * vm.message = 'change'
 * 
 * 想要立即使用更新后的 DOM，这样不行，因为设置 message 后 DOM 还没更新
 * console.log(vm.$el.textContent) // 并不会得到 'change'
 * 
 * 这样才行 nextTick 里面的代码会在 DOM 更新后执行
 * Vue.nextTick(() => console.log(vm.$el.textContent)) // 可以得到 'change'
 */
/**
 * 事件循环：
 * 同步代码执行 ---> 查找异步队列，推入执行栈，执行 Vue.nextTick[事件循环1] ---> 查找异步队列，推入执行栈，执行 Vue.nextTick[事件循环2]...
 */

// ==============================================================================================

// 17. vue 中 $route 和 $router 的区别：
/**
 * $route 是 路由信息对象，包括 path params hash query fullPath matched name 等路由信息参数
 * $router 是 路由实例对象，包括了 路由跳转方法，钩子函数等
 */

// ==============================================================================================
// 18. MVC 和 MVVM 区别
/**
 * MVC 即 模型 --- 视图 --- 控制器，传统后端使用的多一些，目的是为了是 模型 和 视图 能实现代码分离，用户操作都会经过路由处理来调用控制器，再将页面返回给前端
 * 
 * MVVM 即 模型 --- 视图 --- 视图模型，ViewModal 是 视图和模型的桥梁，view 和 modal ，没有直接关系，是通过 ViewModal 自动同步的，因此开发者只需要关注业务卡逻辑，不需要操作 DIM
 * 
 * vue 并没有完全遵循 MVVM 模式，例如：$refs 主要是提供给 js 程序访问的，并不建议在模板中过度依赖它。因为这就意味着在实例之外去访问实例状态，违背了 vue 数据驱动的思想
 */

// ==========================================================================================================

// 19. 请你谈谈对 vuex 的理解
/**
 * vuex 是专为 vue 设计，多组件共享，集中式存储的状态管理模式
 * 采用单向数据流，state 存放状态，getters 为 state 的计算属性，mutations 同步修改 state 的值，actions 异步修改 state 的值，modules 可以模块化，通过 dispatch 触发 actions 提交的 mutations，通过 commit 触发 mutations 修改 state
 * 
 * 插件：Vuex持久化插件(vuex-persistedstate)-解决刷新数据消失的问题
 * 
 * vuex 原理：
 * 1. vuex 利用 minxin 混入，再 beforeCreate 钩子中，将传入的 option 中的 store，赋值给了根实例上的 $store，并让子组件每一级都查到 $parent 复制给了自身 $store，实现多组件共享
 * 2. vuex 的响应式借助了 vue 的响应式原理，将 state 放入新的 vue 实例的 data 上，将 getters 传递给 computed 实现实时监听以及缓存
 */

// =========================================================================================================================
// 20. Vue 组件的渲染流程
/**
 * 1. 组件渲染时都会调用 Vue.extend() 方法，创建一个子组件构造函数
 * 2. 实例化子组件，会将当前传入选项和用户选项合并
 * 3. 实例化子组件，然后手动挂载 $mount，用真实 DOM 替换原来组件
 * 4. 每个组件都会创建一个 Watcher
 * 
 * Vue.extend() 方法：继承 Vue，合并当前组件选项和用户选项，是子组件的构造函数
 */


